<!DOCTYPE html>
<html>
    <head>
        <title>Wavelet Sharpen</title>
        <link rel="stylesheet" type="text/css" href="../css/experiments.css"/>
        <link rel="stylesheet" type="text/css" href="../gradientui/gradientui.css"/>
        <link type="text/css" href="../3rd/custom-theme/jquery-ui-1.8.16.custom.css" rel="stylesheet" />
        <script type="text/javascript" src="../3rd/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="../3rd/jquery-ui-1.8.16.custom.min.js"></script>
        <script type="text/javascript" src="../3rd/colorPicker.js"></script>
        <script type="text/javascript" src="../3rd/three.min.js"></script>
        <script type="text/javascript" src="../gradientui/gradientui.js"></script>
        <!--script type="text/javascript" src="http://mrdoob.github.com/three.js/build/three.min.js"></script-->
        <script type="x-shader/x-vertex" id="standardVertexShader">
            varying vec2 vUv;

            void main()
            {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        </script>
        <script type="x-shader/x-vertex" id="waveletSharpenFragmentShader">
            varying vec2 vUv;

            uniform float screenWidth;
            uniform float screenHeight;

            uniform sampler2D sSource;
            uniform sampler2D iSource;

            uniform int state;
            uniform float amount;
            uniform float mix;

            float step_x = 1.0/screenWidth;
            float step_y = 1.0/screenHeight;

            vec3 minmax_transformX(sampler2D src, float scale) {
                const int radius = 2;
                vec3 n = vec3(0.0);
                vec3 d = vec3(0.0);
                for (int j = -radius; j <= radius; j++) {
                    vec3 x = texture2D(src, vUv + float(j) * vec2(step_x, 0.0)).xyz;
                    vec3 v = vec3(- scale, 0.0, scale);
                    vec3 q = exp(v * x);
                    n += x * q;
                    d += q;
                }
                return n / d;
            }

            vec3 minmax_transformY(sampler2D src, float scale) {
                const int radius = 2;
                vec3 n = vec3(0.0);
                vec3 d = vec3(0.0);
                for (int j = -radius; j <= radius; j++) {
                    vec3 x = texture2D(src, vUv + float(j) * vec2(0.0, step_y)).xyz;
                    vec3 v = vec3(- scale, 0.0, scale);
                    vec3 q = exp(v * x);
                    n += x * q;
                    d += q;
                }
                return n / d;
            }

            #define SQRT_2_PI 2.50662827463
            vec3 gaussian(vec3 x, float mu, float sigma) {
                    vec3 n = - (x - mu) * (x - mu);
                    float m = 2.0 * sigma * sigma;
                    float dn = sigma * SQRT_2_PI;
                    return exp(n / m) / dn;
            }

            vec3 gaussianX(sampler2D src) {
                const int radius = 2;
                const float stddev = 1.5;
                vec3 n = vec3(0.0);
                vec3 d = vec3(0.0);
                for (int j = -radius; j <= radius; j++) {
                    float fj = float(j);
                    vec3 x = texture2D(src, vUv + fj * vec2(step_x, 0.0)).xyz;
                    vec3 g = gaussian(vec3(fj), 0.0, stddev);
                    n += g * x;
                    d += g;
                }
                return n / d;
            }

            vec3 gaussianY(sampler2D src) {
                const int radius = 2;
                const float stddev = 1.5;
                vec3 n = vec3(0.0);
                vec3 d = vec3(0.0);
                for (int j = -radius; j <= radius; j++) {
                    float fj = float(j);
                    vec3 x = texture2D(src, vUv + fj * vec2(0.0, step_y)).xyz;
                    vec3 g = gaussian(vec3(fj), 0.0, stddev);
                    n += g * x;
                    d += g;
                }
                return n / d;
            }

            float slice(sampler2D sSrc, sampler2D iSrc) {
                vec3 x = texture2D(sSrc, vUv).xyz;
                float i = texture2D(iSrc, vUv).x;

                vec3 d = pow(i - x, vec3(-2.0));
                vec3 dx = d * x;
                float weighted = (dx.x + dx.y + dx.z) / (d.x + d.y + d.z);
                return mix * weighted + (1.0 - mix) * i;

                /*
                    float average = (x.x + x.y + x.z) / 3.0;
                    vec3 variance = pow(x - average, vec3(2.0));
                    float stddev = sqrt((variance.x + variance.y + variance.z) / 3.0);
                    vec3 g = gaussian(x, average + mix * (i - average), stddev);
                    vec3 gx = g * x;
                    float d = g.z + g.y + g.z;
                    // underflow
                    if (d <= 0.0) {
                        return x.y;
                    } else {
                        return (gx.x + gx.y + gx.z) / d;
                    }
                */
            }

            void main()
            {
                vec3 result;
                if (state == 0) {
                    result = minmax_transformX(iSource, amount);
                } else if (state == 1) {
                    result = minmax_transformY(sSource, amount);
                } else if (state == 2) {
                    result = gaussianX(sSource);
                } else if (state == 3) {
                    result = gaussianY(sSource);
                } else if (state == 4) {
                    result = vec3(slice(sSource, iSource));
                } else if (state == 5) {
                    result = texture2D(sSource, vUv).xyz;
                }

                gl_FragColor = vec4(result, 1.0);
            }
        </script>
        <script type="text/javascript" src="sharpen.js"></script>
        <meta charset="UTF-8">
        <script>
            $(function()
            {
                load();
            });
        </script>
    </head>
    <body>
        <header>
            <h1>Wavelet Sharpen</h1>
        </header>
        <div id="simulation">
        <canvas id="myCanvas" class="viewer" style="width:1024px;height:1024px"></canvas>
        <aside class="panel">
            <section id="instructions">
                <header><h4>Instructions</h4></header>
                <ol>
                    <li>Adjust the denoise amount.</li>
                </ol>
            </section>
            <section id="controls">
                <h4 class="unsafe">Settings</h4>
                Amount:
                <span class ="remark" id="amount"></span><br/>
                <div id="sld_amount" class="slider"></div>

                Mix:
                <span class ="remark" id="mix"></span><br/>
                <div id="sld_mix" class="slider"></div>
            </section>
        </aside>
        </div>
        <footer>
                <div id="copyright">
                    &copy;2014 <a href="https://twitter.com/cornusammonis">@cornusammonis</a>
                    <a href="https://github.com/CornuAmmonis/jsexp">Github</a><br>
                    <a id="notworking" href="#">Not working?</a>
                </div>
        </footer>
        
        <div id="requirement_dialog" title="Requirements">
            <p>This simulation requires the GL extensions framebuffer_object and texture_float.
            If you cannot see the simulation your system probably lacks at least one of these extensions.</p>
            
            <p>In Google Chrome, you can see the available GL extensions going to chrome://gpu.</p>
        </div>
    </body>
</html>
